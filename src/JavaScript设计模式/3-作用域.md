# 第三章 作用域

## 作用域

理解闭包需要先弄明白两个概念，作用域链和变量生存周期

### 作用域链

你不知道的 js 中有个形象的比喻，“把一座建筑比作程序中的嵌套作用域链。第一层楼代表当前的执行作用域，也就是你所处的位置。建筑的顶层代表全局作用域。”  
“先在当前楼层进行查找，如果没有找到，就会坐电梯前往上一层楼，如果还是没有找到就继续向上，以此类推。一旦抵达顶层（全局作用域）”

### 函数作用域

JavaScript 具有基于函数的作用域，当我们把代码片段外部添加函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问函数内部的任何内容
例如：

```js
function foo() {
  var a = 2;
  console.log(a); // 2
}
foo();
console.log(a); // ReferenceError: a is not defined
```

```js
var a = 1;
function foo() {
  var a = 2;
  console.log(a); // 2
}
foo();
console.log(a); // 1
```

这样看似实现了封装的目的，但是这么做有几个问题

- 要额外创建 foo 函数
- 污染当前作用域（这段代码之前或之后存在其他 foo 变量，可能导致异常）
- 必须显式调用 foo 函数

#### IIFE 立即执行函数表达式

有没有没有名称函数，而且还能自执行呢，这样就解决了以上的几个问题
例子：

```js
var a = 1;
(function foo() {
  var a = 2;
  console.log('我来自内部', foo); // 我来自内部 ƒ foo() {...}
  console.log(a); // 2
})();
console.log(a); // 1
console.log(foo); // ReferenceError: foo is not defined foo 去哪了???
```

函数声明 VS 函数表达式

函数表达式：

- function 不是声明的第一个词
- 作用域 绑定在函数表达式自身的函数中
- function 是否命名都一样, 这里只是为了输出展示，当然如果没有名称，内部可以通过 arguments.callee 来获取当前执行的函数
- 比如 (function foo(){ .. }) foo 只能在.. 所代表的位置中被访问，外部作用域则不行

函数声明：

- function 是声明中的第一个词
- 作用域 绑定在函数所在的作用域
- 比如 function foo() {} foo 被绑定在声明时的作用域 例子中是全局 也就是 window

```js
// 类似的还有
!(function() {})();
+(function() {})();
-(function() {})();
~(function() {})();
void (function() {})();
new (function() {})();

(function() {}.call());
(function() {}.call());
// 这两种方式，会有不好的情况：如果括号前面有东西
a(function() {}).call();
//等价于
a().call();
```

### 块作用域

#### JavaScript 没有块作用域？

除 JavaScript 外的很多编程语言都支持块作用域，那么 JavaScript 没有块作用域是否正确呢？  
可以理解为 JavaScript 中，只有函数作用域，全局作用域，没有块作用域。特殊情况除外（后面会说到 try cache/let/const）

例子：
这个示例中，i 是全局的，所以 for 循环外部可以获取变量 i

```js
// 同步输出 依次输出0-9
console.log('变量提升 ', i); // 变量提升 undefined
for (var i = 0; i < 10; i++) {
  console.log(i);
}
console.log('循环执行完毕 全局变量 ', i); // 循环执行完毕 全局变量 10
```

看了上面的例子，下面这个就好理解了，setTimeout 属于宏任务，执行时依次在事件队列尾部添加回调。等到当前代码（执行栈）执行完，就去事件队列中查找要执行的事件放入主线程，然后同步的执行

```js
// 异步输出 输出10次10
for (var i = 0; i < 10; i++) {
  setTimeout(() => {
    // console执行时 for循环已经执行完毕 此时i=10
    console.log(i);
  }, 0);
}
```

#### JavaScript 实现块作用域

try/catch

```js
try {
  undefined(); // 执行一个非法操作来强制制造一个异常
} catch (err) {
  console.log(err); // 能够正常执行！
}

console.log(err); // ReferenceError: err not found
```

let/const
es5 引入了 let/const，用于创建块作用域，同时声明的变量不再提升作用域

```js
// 异步输出 依次输出0-9
for (let i = 0; i < 10; i++) {
  setTimeout(() => {
    // console执行时 for循环已经执行完毕 此时i=10
    console.log(i);
  }, 0);
}

// 这样也行
for (var i = 0; i < 10; i++) {
  let j = i; // 这里创建了块级作用域
  setTimeout(() => {
    // console执行时 for循环已经执行完毕 此时i=10
    console.log(j);
  }, 0);
}
```

IIFE 立即执行函数（模拟块作用域）

```js
// 异步输出 依次输出0-9 （利用闭包改造）
for (var i = 0; i < 10; i++) {
  (function(j) {
    setTimeout(() => {
      // console执行时 j取的是当前作用域中的值 所以输出0-9
      console.log(j);
    }, 0);
  })(i);
}

// 还可以这样
for (var i = 0; i < 10; i++) {
  (function() {
    var j = i;
    setTimeout(() => {
      console.log(j);
    }, 0);
  })();
}
```

![for循环中let、var问题](https://blog.csdn.net/a__person/article/details/103780967)
