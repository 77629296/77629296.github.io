# 第一章 面向对象的 JavaScript

## 多态的含义

因为 js 是动态类型语言，所以不需要转型来达到多态的效果，这里使用 ts 模拟
同一方法在不同对象上表现不同，比如动物都有发出叫声这个方法，鸡和鸭的声音不同，代码如下

```typescript
// 在线运行ts https://c.runoob.com/compile/5577
abstract class Animal {
  abstract makeSound(): void
}
class Chicken extends Animal {
  public makeSound(): void {
    console.log('咯咯咯')
  }
}
class Duck extends Animal {
  public makeSound(): void {
    console.log('嘎嘎嘎')
  }
}

const chicken: Chicken = new Chicken()
chicken.makeSound() //咯咯咯

const duck: Duck = new Duck()
duck.makeSound() //嘎嘎嘎

// 根据实际类型调用方法
const animalMakeSound = (animal: Duck | Chicken) => {
  animal.makeSound()
}
animalMakeSound(chicken)
animalMakeSound(duck)
```

## 多态的使用

```js
var googleMap = {
  show: function () {
    console.log('开始渲染谷歌地图')
  },
}
var baiduMap = {
  show: function () {
    console.log('开始渲染百度地图')
  },
}

// 后续增加类型 需要修改原代码
var renderMap = function (type) {
  if (type === 'google') {
    googleMap.show()
  } else if (type === 'baidu') {
    baiduMap.show()
  }
}
renderMap('google') // 输出：开始渲染谷歌地图
renderMap('baidu') // 输出：开始渲染百度地图

/**
 * 修改后
 * 抽象相同的show方法，不同的地图对象都实现show方法
 */

var renderMap = function (map) {
  if (map.show instanceof Function) {
    map.show()
  }
}

renderMap(googleMap)
renderMap(baiduMap)

// 新增一种地图时，只需增加地图对象并实现show方法，无需改动renderMap
var sosoMap = {
  show: function () {
    console.log('开始渲染搜搜地图')
  },
}
renderMap(sosoMap) // 输出：开始渲染搜搜地图
```

## 三种创建对象的方式

### 前两种 字面量、object 构造器

从下面这两个判断可以看出 两者是等价的，都是创建一个空的对象，**proto**指向 Object.prototype

```js
// 1、{}
// 2、new Object()
;({}.__proto__ === Object.prototype) // true
new Object().__proto__ === Object.prototype // true
```

### 第三种 Object.create({})

创建一个空的对象 **proto**指向第一个参数

```js
/**
 * 先看一下方法签名
 * proto 必须有，表示新建对象的原型对象
 * propertiesObject 添加到新创建对象的可枚举属性
 */
Object.create(proto, [propertiesObject])

/**
 * 3、Object.create({})
 * 新建一个空对象{}，{}的__proto__指向参数{}
 * 参数{}的__proto__指向Object.prototype
 */

Object.create({}).__proto__.__proto__ === Object.prototype // true
Object.create(Object.prototype).__proto__ === Object.prototype // true

// 新建一个真空对象
Object.create(null)
Object.create(null).__proto__ // undefined
```

### 模拟实现 new 方法

// 调用方式：const foo = mockNew(Foo, ...others)

```js
function mockNew(...args) {
  // 1.取出args数组第一个参数，也就是构造函数
  const constructor = args.shift()

  // 2.创建一个空对象 且让这个空对象继承构造函数的prototype属性
  const newObj = Object.create(constructor.prototype)

  // 3.执行构造函数，得到返回结果
  const result = constructor.apply(newObj, args)

  // 4.如果返回值类型是对象，这直接返回该对象，否则返回新对象
  return typeof result === 'object' && result != null ? result : newObj
}
```
