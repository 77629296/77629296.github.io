# 第三章 作用域与闭包

## 闭包

理解闭包需要先弄明白两个概念，作用域链和变量生存周期

### 作用域链

你不知道的 js 中有个形象的比喻，“把一座建筑比作程序中的嵌套作用域链。第一层楼代表当前的执行作用域，也就是你所处的位置。建筑的顶层代表全局作用域。”  
“先在当前楼层进行查找，如果没有找到，就会坐电梯前往上一层楼，如果还是没有找到就继续向上，以此类推。一旦抵达顶层（全局作用域）”

### 函数作用域

JavaScript 具有基于函数的作用域，当我们把代码片段外部添加函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问函数内部的任何内容
例如：

```js
function foo() {
  var a = 2;
  console.log(a); // 2
}
foo();
console.log(a); // ReferenceError: a is not defined
```

```js
var a = 1;
function foo() {
  var a = 2;
  console.log(a); // 2
}
foo();
console.log(a); // 1
```

这样看似实现了封装的目的，但是这么做有几个问题

- 要额外创建 foo 函数
- 污染当前作用域（这段代码之前或之后存在其他 foo 变量，可能导致异常）
- 必须显式调用 foo 函数

#### IIFE 立即执行函数表达式

有没有没有名称函数，而且还能自执行呢，这样就解决了以上的几个问题
例子：

```js
var a = 1;
(function foo() {
  var a = 2;
  console.log('我来自内部', foo); // 我来自内部 ƒ foo() {...}
  console.log(a); // 2
})();
console.log(a); // 1
console.log(foo); // ReferenceError: foo is not defined foo 去哪了???
```

```js
// 类似的还有
!function(){}()
+function(){}()
-function(){}()
~function(){}()
void function(){}()
new function(){}()
function(){}() === function(){}.call()

(function(){}).call()
(function(){}.call())
// 这两种方式，会有不好的情况：如果括号前面有东西
a
(function(){}).call()
//等价于
a().call()
```

这就引申出另一个问题，函数声明 VS 函数表达式

区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。

比较一下前面两个代码片段。第一个片段中 foo 被绑定在所在作用域中，可以直接通过 foo() 来调用它。第二个片段中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。

换句话说，(function foo(){ .. }) 作为函数表达式意味着 foo 只能在.. 所代表的位置中被访问，外部作用域则不行

摘录来自: [美]辛普森（Kyle Simpson）. 你不知道的 JavaScript（上卷） (图灵程序设计丛书)。

> 以上代码 foo 是否命名都一样，这里只是为了输出展示，当然如果没有名称，内部可以通过 arguments.callee 来获取当前执行的函数

### 块作用域

#### JavaScript 没有块作用域？

除 JavaScript 外的很多编程语言都支持块作用域，那么 JavaScript 没有块作用域是否正确呢？  
可以理解为 JavaScript 中，只有函数作用域，全局作用域，没有块作用域。特殊情况除外（后面会说到 try cache/let/const）

例子：
这个示例中，i 是全局的，所以 for 循环外部可以获取变量 i

```js
// 同步输出 依次输出0-9
console.log('变量提升 ', i); // 变量提升 undefined
for (var i = 0; i < 10; i++) {
  console.log(i);
}
console.log('循环执行完毕 全局变量 ', i); // 循环执行完毕 全局变量 10
```

看了上面的例子，下面这个就好理解了，作用域+事件循环机制

```js
// 异步输出 输出10次10
for (var i = 0; i < 10; i++) {
  setTimeout(() => {
    // console执行时 for循环已经执行完毕 此时i=10
    console.log(i);
  }, 0);
}
```

#### JavaScript 实现块作用域

try/catch

```js
try {
  undefined(); // 执行一个非法操作来强制制造一个异常
} catch (err) {
  console.log(err); // 能够正常执行！
}

console.log(err); // ReferenceError: err not found
```

let/const
es5 引入了 let/const，用于创建块作用域，同时声明的变量不再提升作用域

```js
// 异步输出 依次输出0-9
for (let i = 0; i < 10; i++) {
  setTimeout(() => {
    // console执行时 for循环已经执行完毕 此时i=10
    console.log(i);
  }, 0);
}
```

IIFE 立即执行函数（模拟块作用域）

```js
// 异步输出 依次输出0-9 （利用闭包改造）
for (var i = 0; i < 10; i++) {
  (function(j) {
    setTimeout(() => {
      // console执行时 j取的是当前作用域中的值 所以输出0-9
      console.log(j);
    }, 0);
  })(i);
}
```

### 闭包

#### 这就是闭包

```js
function foo() {
  var a = 2;
  function bar() {
    console.log(a);
  }
  return bar;
}
var baz = foo();
baz(); // 2 ———— 朋友，这就是闭包的效果。”
```

### 闭包的用处
