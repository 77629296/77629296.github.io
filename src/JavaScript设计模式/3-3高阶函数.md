# 第 3 章 3.3 高阶函数

所谓高阶函数，是指使用其他函数作为参数、或者返回一个函数作为结果的函数

## 高阶函数

常用的数组方法，比如 map/reduce/filter/sort 等。

## 实现 AOP

AOP 也就是面向切面编程，比如，一个函数输出 2，在输出 2 之前输出 1，之后输入 3。当然条件是在不改动原功能代码的基础上实现

```js
console.log(1); // 横切面
console.log(2); // 原代码
console.log(3); // 横切面

Function.prototype.before = function(beforefn) {
  var self = this; // 保存原函数的引用
  return function() {
    // 返回包含了原函数和新函数的"代理"函数 function拥有before/after方法
    beforefn.apply(this, arguments); // 执行新函数，修正 this
    return self.apply(this, arguments); // 执行原函数
  };
};
Function.prototype.after = function(afterfn) {
  var self = this;
  return function() {
    // 执行原函数
    var ret = self.apply(this, arguments);
    // 执行after
    afterfn.apply(this, arguments);
    // 返回原函数的返回值
    return ret;
  };
};

var func = function() {
  console.log(2);
};
func = func
  .before(function() {
    console.log(1);
  })
  .after(function() {
    console.log(3);
  });

func();
```

## 高阶函数应用

### 柯里化与反柯里化

#### 柯里化

就是把接受多个参数的函数，变换成接受单参数的函数，内部再返回调用下一个单参数的函数。书中实现了通用的 currying 函数，这个有点东西

```js
/**
 * 这里实现了一个通用的包装函数，保存args的引用
 * 调用时传递参数 则push进args，同时返回当前函数（也就是说可以连续调用）
 * 调用时不传参数 则使用args执行传入的函数fn
 */

var currying = function(fn) {
  var args = [];
  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, args);
    } else {
      [].push.apply(args, arguments);
      return arguments.callee;
    }
  };
};

// 这里使用自执行函数只是为了模仿块级作用域 方便理解完全可以改为普通函数
var cost = (function() {
  var money = 0;
  return function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      money += arguments[i];
    }
    return money;
  };
})();
var cost = currying(cost); // 转化成 currying 函数
cost(100); // 未真正求值
cost(200); // 未真正求值
cost(300); // 未真正求值
// cost(100)(200)(300) 还可以这样调用
console.log(cost()); // 求值并输出：600
```

#### 反柯里化

如果按照字面意思，就是把接受单个参数的函数，变换成接受多参数的函数。  
这样理解也没问题，但是总感觉哪里不对，另外一种更通俗的解释是函数的借用，是函数能够接受处理其他对象，通过借用泛化、扩大了函数的使用范围。

```js
Function.prototype.uncurrying = function() {
  // self 是调用uncurrying的函数 也即是Array.prototype.push
  var self = this;
  return function() {
    /**
     * arguments是push传入的参数 [{"length": 1,"0": 1}, 2] (类数组)
     * obj是从arguments截取的第一个参数 {"length": 1,"0": 1}
     * 此时arguments为[2](类数组)
     */

    var obj = Array.prototype.shift.call(arguments);
    // Array.prototype.push.apply(obj, [2])
    return self.apply(obj, arguments);

    // 分析下书上的另外一种实现 有种解方程的感觉
    // return Function.prototype.call.apply(self, arguments);
    /**
     * Function.prototype.call.apply(self, arguments)
     * -> (Function.prototype.call).apply(self, arguments)
     * -> (Function.prototype.call).call(self, obj, 2)
     * -> self.call(obj, 2)
     * -> Array.prototype.push.apply(obj, [2])
     */
  };
};

var push = Array.prototype.push.uncurrying();
var obj = {
  length: 1,
  '0': 1,
};
// push从接收1个参数 变为接收2个参数
push(obj, 2);
console.log(obj); // 输出：{0: 1, 1: 2, length: 2}

// 如果call.apply让你无语的话，下面这个就有点崩溃了
var uncurrying = Function.prototype.uncurrying.uncurrying();
var pushAgain = uncurrying(Array.prototype.push);
pushAgain(obj, 2);
console.log(obj); // 输出：{0: 1, 1: 2, length: 2}
```

> 你没有看错，uncurrying 还能借用自己，这也许就是人们说 js 灵活的原因吧。
> 因为 Function.prototype.uncurrying 是函数，我们再函数的原型链上增加了 uncurrying 方法，试试这个你就知道为什么了。console.log(Function.prototype.uncurrying.uncurrying.uncurrying)...原型链就像黑洞，没有尽头

### 函数节流 throttle

### 函数防抖

原理：使用 setTimeout 延迟执行，如果该次延迟执行还没有完成，则忽略接下来调用该函数的请求

```js
var throttle = function(fn, interval) {
  var __self = fn, // 保存需要被延迟执行的函数引用
    timer, // 定时器
    firstTime = true; // 是否是第一次调用
  return function() {
    var args = arguments,
      __me = this;
    if (firstTime) {
      // 如果是第一次调用，不需延迟执行
      __self.apply(__me, args);
      return (firstTime = false);
    }
    if (timer) {
      // 如果定时器还在，说明前一次延迟执行还没有完成
      return false;
    }
    timer = setTimeout(function() {
      // 延迟一段时间执行
      clearTimeout(timer);
      timer = null;
      __self.apply(__me, args);
    }, interval || 500);
  };
};
```

### 分时函数

书上的例子是在短时间内往页面中大量添加 DOM 节点，优化为每隔一段时间创建一些节点。其实仔细想下，我们平时的项目也是这样，只不过这个事情是框架做的。

> react16 采用了时间片的方式解决卡顿问题，只不过它分的更细，以帧为单位，所以看上去渲染很流畅。

模拟 react 实现分片渲染，这样就不用设置时间间隔，浏览器不忙的时候执行

```js
var timeChunk = function(ary, fn, count) {
  var obj, t;
  var len = ary.length;
  var start = function() {
    for (var i = 0; i < Math.min(count || 1, ary.length); i++) {
      var obj = ary.shift();
      fn(obj);
    }
  };
  return function(deadline) {
    while (deadline.timeRemaining() > 0 || deadline.didTimeout) {
      start();
    }
    if (ary.length) {
      requestIdleCallback(arguments.callee);
    }
  };
};

var ary = [];
for (var i = 1; i <= 1000; i++) {
  ary.push(i);
}
var renderFriendList = timeChunk(
  ary,
  function(n) {
    var div = document.createElement('div');
    div.innerHTML = n;
    document.body.appendChild(div);
  },
  8,
);

requestIdleCallback(renderFriendList, { timeout: 2000 });
```

### 惰性加载

核心是函数重写

```js
var addEvent = function(elem, type, handler) {
  if (window.addEventListener) {
    addEvent = function(elem, type, handler) {
      elem.addEventListener(type, handler, false);
    };
  } else if (window.attachEvent) {
    addEvent = function(elem, type, handler) {
      elem.attachEvent('on' + type, handler);
    };
  }
  // 第一次执行 重写addEvent = newFunction 调用newFunction，后续直接执行newFunction
  addEvent(elem, type, handler);
};
```

[JS 中的反柯里化](https://segmentfault.com/a/1190000012912503)
